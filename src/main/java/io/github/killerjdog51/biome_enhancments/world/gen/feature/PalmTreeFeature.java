package io.github.killerjdog51.biome_enhancments.world.gen.feature;

import java.util.Random;
import java.util.Set;
import java.util.function.Function;

import com.mojang.datafixers.Dynamic;

import io.github.killerjdog51.biome_enhancments.blocks.PalmLeavesBlock;
import io.github.killerjdog51.biome_enhancments.init.ModBlocks;
import io.github.killerjdog51.biome_enhancments.init.WorldGeneration;
import net.minecraft.block.BlockState;
import net.minecraft.tags.BlockTags;
import net.minecraft.util.Direction;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MutableBoundingBox;
import net.minecraft.world.IWorldWriter;
import net.minecraft.world.World;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.Biomes;
import net.minecraft.world.gen.IWorldGenerationReader;
import net.minecraft.world.gen.WorldGenRegion;
import net.minecraft.world.gen.feature.AbstractTreeFeature;
import net.minecraft.world.gen.feature.NoFeatureConfig;

/**
*
* Description of tree generation mechanics and how I personally handle tree generation
*
* I have decided to implement comments within my tree generation code for my Minecraft mod in case I ever wanted to reference it for another project,
* required to return to it in the future due to an issue, or if other people wished to understand how tree generation works in the game of Minecraft.
* Because when you first open up a tree generation file it can look confusing and complicated.
* This is mostly because Mojang uses a waterfall technique for generating trees, which is generally frowned upon in the programming/computer science community.
* It is much more respected to utilize functions/methods to make your code more readable and understandable for other people.
* Another benefit to using functions is that they are re-callable.
* So when creating more complex trees like I have, it is usually a good idea to use functions and split complex code into more manageable pieces.
* 
* I will try my best to walk through my code and explain what is happening.
* But first I wanted to point out that Minecraft tree generation is split into two parts, checking/testing and then generating.
* Minecraft uses mutable blocks to pre-generate the tree to make sure it can fully be completed or will fit within a designated bounding box.
* Essentially, this is the code that is used to prevent a tree from being generated from too small of a space.
* This code is usually the same for all trees, so there isn’t too much that needs to be altered here or should be fretted about (I will explain it as best I can none the less though). 
* 
* The important part is the generation portion. Once the game confirms that the tree is capable of generating within a certain spot then it will create the tree within the game.
* You can tackle this however you wish, but I generally prefer to start big (or from a central point) and then go small (or move away from that central point.
* Another thing that I prefer to do is split my tree generation into different parts/features or more manageable layers.
* I will first build a mock-up of my tree in the game and separate the major differences/unique parts of the tree.
* I will then write down on paper the technicalities of how I want the tree to generate.
* This includes a min and max height for my tree, if I want any special properties in how the tree generates (does the tree generate branches or roots? And how do they generate?),
* and anything else I think is necessary to understand before writing the code for generating my tree. 
* 
* Now that I have briefly explained why I generate my trees using functions,
* how Minecraft tree generation generally works and how it can be split into two defining portions,
* and how I handle defining/generating my trees it is time to look at the actual code.
*/

/**
*
* Description of Palm tree generation/mechanics
*
* Palms are a new Desert/Beach specific tree.
* Like most other trees they generate with a single trunk, but their leaves are split into three distinct layers.
* You have the bottom layer which will grow two new crops.
* You have the middle layer, which is a little bigger.
* Finally, there is the top “floppy” layer of leaves that provide a distinct palm-tree-like shape.
* As briefly mentioned, Palm trees will bring two new crops to the game.
* The concept is to use a single tree to generate either coconuts in tropical biomes or dates in arid/desert-like biomes.
* While Palms aren’t the only trees that can grow a crop in the game (Jungle trees and Cocoa Pods),
* they are the only tree that is required to generate naturally for that crop to grow.
* Basically, you can’t place a palm leaf and expect a coconut/date to grow,
* only leaves generated by the tree will be capable to grow coconuts/dates.
* Another feature is that the crops can only grow from the leaf block touching the tree’s trunk. 
*/

public class PalmTreeFeature extends AbstractTreeFeature<NoFeatureConfig>
{
	// Some global variables
	//(generally expected to use the "final" to make the variable unchangable. But since I change the top log to a wood block and have different types of leaves I prefer to not finalize these variables)
	private static BlockState LOG = ModBlocks.PALM_LOG.getDefaultState();
    private static BlockState LEAF = ModBlocks.PALM_LEAVES.getDefaultState();
    private final int minHeight = 5;
    
	public PalmTreeFeature(Function<Dynamic<?>, ? extends NoFeatureConfig> configIn)
	{
		super(configIn, false);
	    setSapling((net.minecraftforge.common.IPlantable)ModBlocks.PALM_SAPLING);
	}

	public boolean place(Set<BlockPos> changedBlocks, IWorldGenerationReader world, Random rand, BlockPos pos, MutableBoundingBox box)
	{
		// Setting the height of the tree
		int height = this.minHeight + rand.nextInt(4);

		// This tests/checks if the tree is able to grow, if not then we exit
		if (!this.ensureGrowable(world, pos, height))
       {
           return false;
       }	
		else
		{
			
			// Sets the leaf type for the tree
			this.SetLeafType(world, pos, rand);
			
			// Sets the direction the tree may sway
            Direction direction = Direction.Plane.HORIZONTAL.random(rand);
            int xPos = pos.getX();
			int zPos = pos.getZ();
			int top = 0;
				
			// Generate the trunk of the tree
			for(int block = 0; block <= height; block++)
			{
				int yPos = pos.getY() + block;
					
				// Move the logs to make the tree sway in a certain direction
				if(yPos > pos.getY() && yPos <= (pos.getY() + (height - 3)))
				{
					if(rand.nextInt(10) == 1)
					{
					xPos += direction.getXOffset();
					zPos += direction.getZOffset();
					}
				}
				
				// Change the top block of the tree to be wood instead of a log
				if(yPos == (pos.getY() + height))
				{
					LOG = ModBlocks.PALM_WOOD.getDefaultState();
				}
				else
				{
					LOG = ModBlocks.PALM_LOG.getDefaultState();
				}
				
					BlockPos blockpos = new BlockPos(xPos, yPos, zPos);

                    if (isAirOrLeaves(world, blockpos))
                    {
                        this.placeLogAt(changedBlocks, world, blockpos, box);
                        top = yPos;
                    }
				}
			
                BlockPos topBlock = new BlockPos(xPos, top, zPos);
                this.placeLeafAt(changedBlocks, world, topBlock.add(0, 1, 0), box);

                // Generate the leaves at the top of the tree
                for(Direction side : Direction.Plane.HORIZONTAL)
                {
                	
                	leafLayer1(changedBlocks, world, topBlock, side, box);
                	leafLayer2(changedBlocks, world, topBlock, side, box);
                	leafLayer3(changedBlocks, world, topBlock, side, box);

                }

                return true;
			}
			
	}

	
	// I want the Palm tree to grow two different crops, so this sets the leaves to the specific type.
		private void SetLeafType(IWorldGenerationReader worldIn, BlockPos pos, Random rand)
		{
			
			Biome biome = null;
			
			// Test if the tree is generated naturally (WorldGenRegion) or generated from a sapling (World)
			if (worldIn instanceof WorldGenRegion)
			{
				WorldGenRegion chunk = (WorldGenRegion) worldIn;
				biome = chunk.getBiome(pos);
			}
			else if (worldIn instanceof World)
			{
				World world = (World) worldIn;
				biome = world.getBiome(pos);
			}
			// Something went wrong
			else
			{
				LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.NORMAL);
				return;
			}
			
			double temp = biome.getTemperature(pos);
			
			// Logically Palm trees shouldn't even grow in too cold or too hot of climates, but since this is Minecraft they just won't grow fruit
			if (biome.getTempCategory().equals(Biome.TempCategory.COLD) || biome.getCategory().equals(Biome.Category.NETHER))
			{
				LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.NORMAL);
			}
			
			// If a Palm tree is generated in a desert/arid climate we only want dates to grow
			else if ( biome.equals(WorldGeneration.OASIS) || temp >= 1.9D)
			{
				LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.DATE);
			}
			
			// If a Palm tree is generated in a beach or tropical climate we only want coconuts to grow
			else if ( biome.equals(Biomes.BEACH) || ( temp >= 0.90D && temp < 1.0D ))
			{
				LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.COCONUT);
			}
			else
			{
				// I wasn't sure where to put this, but if a Palm tree (for some odd reason) is generated in a lukewarm/warm ocean then I only want coconuts to grow
				if (biome.getCategory().equals(Biome.Category.OCEAN))
				{
					if ( (biome.equals(Biomes.WARM_OCEAN) || biome.equals(Biomes.DEEP_WARM_OCEAN)) || (biome.equals(Biomes.LUKEWARM_OCEAN) || biome.equals(Biomes.DEEP_LUKEWARM_OCEAN)))
					{
						LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.COCONUT);
						return;
					}
					else if ( biome.equals(Biomes.FROZEN_OCEAN) || biome.equals(Biomes.DEEP_FROZEN_OCEAN))
					{
						LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.NORMAL);
						return;
					}
				}
				
				// For every other biome I want there to be a 2/5 chance of fruit to grow, otherwise the Palm tree will be normal
				switch(rand.nextInt(6))
				{
				case 1:
					LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.DATE);
					break;
				case 2:
					LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.COCONUT);
					break;
				default:
					LEAF = ModBlocks.PALM_LEAVES.getDefaultState().with(PalmLeavesBlock.TYPE, PalmLeavesBlock.Type.NORMAL);
					break;


				}
			}
			
		}
		
	// Generate the lowest leaf layer where the crops will grow
	private void leafLayer1(Set<BlockPos> changedBlocks, IWorldGenerationReader worldIn, BlockPos pos, Direction side, MutableBoundingBox box)
	{
		int X = side.getXOffset();
		int Z = side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, -1, Z), box);
		
		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, -1, Z), box);
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, -2, Z), box);

	}
	
	// Generate the middle leaf layer 
	private void leafLayer2(Set<BlockPos> changedBlocks, IWorldGenerationReader worldIn, BlockPos pos, Direction side, MutableBoundingBox box)
	{
		int X = side.getXOffset();
		int Z = side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 0, Z), box);
		
		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 0, Z), box);

		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 0, Z), box);

		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 0, Z), box);
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, -1, Z), box);
	}
	
	// Generate the top leaf layer with the big floppy leaves
	private void leafLayer3(Set<BlockPos> changedBlocks, IWorldGenerationReader worldIn, BlockPos pos, Direction side, MutableBoundingBox box)
	{
		int X = side.getXOffset();
		int Z = side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 1, Z), box);
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 2, Z), box);

		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 2, Z), box);
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 3, Z), box);

		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 3, Z), box);
		
		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 3, Z), box);
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 2, Z), box);

		X += side.getXOffset();
		Z += side.getZOffset();
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 2, Z), box);
		this.placeLeafAt(changedBlocks, worldIn, pos.add(X, 1, Z), box);
	}
	
	// Just as the title says, this sets a log block in the world
	private void placeLogAt(Set<BlockPos> changedBlocks, IWorldWriter worldIn, BlockPos pos, MutableBoundingBox box)
    {
		this.setLogState(changedBlocks, worldIn, pos, LOG, box);
    }

	// Just as the title says, this sets a leaf block in the world
    private void placeLeafAt(Set<BlockPos> changedBlocks, IWorldGenerationReader worldIn, BlockPos pos, MutableBoundingBox box)
    {
        if (isAirOrLeaves(worldIn, pos))
        {
    		this.setLogState(changedBlocks, worldIn, pos, LEAF, box);
        }
    }
    
 // To test if the tree can grow we first check if there is available space and then if the blocks underneath can sustain our tree
    protected boolean ensureGrowable(IWorldGenerationReader worldIn, BlockPos treePos, int height)
    {
        return this.isSpaceAt(worldIn, treePos, height) && this.ensureViableBlockUnderneath(treePos, worldIn);
    }
    
    // Check if there is space for the tree to grow
 	private boolean isSpaceAt(IWorldGenerationReader worldIn, BlockPos pos, int height)
    {
 		boolean flag = true;
		int x = pos.getX();
		int y = pos.getY();
		int z = pos.getZ();
		
	     // Obviously we don't want the tree to grow in the void or above the build limit
		 if (y >= 1 && y + height + 1 <= 256)
		 {
			 
	    	// Extra math in case our tree is taller than expected
			for(int yPos = y; yPos <= y + 1 + height; yPos++)
			{
				int b0 = 1;
				if(yPos == y) b0 = 0;
				if(yPos >= y + 1 + height - 2) b0 = 2;
				
	           // Use mutable blocks to test if the location is available
	            BlockPos.MutableBlockPos mutable = new BlockPos.MutableBlockPos();
	            
	            
	            // We check each position for future blocks
	            for(int xPos = x - b0; xPos <= x + b0 && flag; xPos++)
	            {
	            	for(int zPos = z - b0; zPos <= z + b0 && flag; zPos++)
	            	{
	            		if(yPos >= 0 && yPos < 256)
	            		{
	            			
	                        // We check if our future blocks can be placed in their respective location
	            			if(!func_214587_a(worldIn, mutable.setPos(xPos, yPos, zPos)))
	            			{
	            				
	                     	   // If a block is in the way we immediately exit the function and return false (ie: tree will not grow) 
	            				flag = false;
	            			}
	            		}
	            		else 
	            		{
	            			flag = false;
	            		}
	            	}
	            }
			}
			
			return flag;
		 }
		 
	    //Tree was either in void or above build limit
		 else
		 {
			 return false;
		 }
    }
 	
 	// Check if the tree can generate on the block underneath
 	private boolean ensureViableBlockUnderneath(BlockPos pos, IWorldGenerationReader worldIn)
    {
        // If the block underneath is considered to be a dirt or sand variant then we allow the tree to generate
 		if ((isSoil(worldIn, pos.down(), getSapling()) || worldIn.hasBlockState(pos.down(), (state) -> state.isIn(BlockTags.SAND))))
		{
 			// I don't want to set sand to dirt
 			if(isSoil(worldIn, pos.down(), getSapling()))
 			{
 				this.setDirtAt(worldIn, pos.down(), pos);
 			}
            return true;
		}
 		else
 		{
 			return false;
 		}
    }
 	
}
